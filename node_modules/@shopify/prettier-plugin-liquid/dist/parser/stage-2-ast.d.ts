import { ConcreteAttributeNode, LiquidHtmlCST, ConcreteLiquidLiteral } from '../parser/stage-1-cst';
import { Comparators, NamedTags, NodeTypes, Position } from '../types';
export declare type LiquidHtmlNode = DocumentNode | YAMLFrontmatter | LiquidNode | HtmlDoctype | HtmlNode | AttributeNode | LiquidVariable | LiquidExpression | LiquidFilter | LiquidNamedArgument | AssignMarkup | CycleMarkup | ForMarkup | RenderMarkup | PaginateMarkup | RawMarkup | RenderVariableExpression | LiquidLogicalExpression | LiquidComparison | TextNode;
export interface DocumentNode extends ASTNode<NodeTypes.Document> {
    children: LiquidHtmlNode[];
    name: '#document';
}
export interface YAMLFrontmatter extends ASTNode<NodeTypes.YAMLFrontmatter> {
    body: string;
}
export declare type LiquidNode = LiquidRawTag | LiquidTag | LiquidDrop | LiquidBranch;
export declare type LiquidStatement = LiquidRawTag | LiquidTag | LiquidBranch;
export interface HasChildren {
    children?: LiquidHtmlNode[];
}
export interface HasAttributes {
    attributes: AttributeNode[];
}
export interface HasValue {
    value: (TextNode | LiquidNode)[];
}
export interface HasName {
    name: string | LiquidDrop;
}
export declare type ParentNode = Extract<LiquidHtmlNode, HasChildren | HasAttributes | HasValue | HasName>;
export interface LiquidRawTag extends ASTNode<NodeTypes.LiquidRawTag> {
    name: string;
    markup: string;
    body: RawMarkup;
    whitespaceStart: '-' | '';
    whitespaceEnd: '-' | '';
    delimiterWhitespaceStart: '-' | '';
    delimiterWhitespaceEnd: '-' | '';
    blockStartPosition: Position;
    blockEndPosition: Position;
}
export declare type LiquidTag = LiquidTagNamed | LiquidTagBaseCase;
export declare type LiquidTagNamed = LiquidTagAssign | LiquidTagCase | LiquidTagCapture | LiquidTagCycle | LiquidTagDecrement | LiquidTagEcho | LiquidTagFor | LiquidTagForm | LiquidTagIf | LiquidTagInclude | LiquidTagIncrement | LiquidTagLayout | LiquidTagLiquid | LiquidTagPaginate | LiquidTagRender | LiquidTagSection | LiquidTagSections | LiquidTagTablerow | LiquidTagUnless;
export interface LiquidTagNode<Name, Markup> extends ASTNode<NodeTypes.LiquidTag> {
    name: Name;
    markup: Markup;
    children?: LiquidHtmlNode[];
    whitespaceStart: '-' | '';
    whitespaceEnd: '-' | '';
    delimiterWhitespaceStart?: '-' | '';
    delimiterWhitespaceEnd?: '-' | '';
    blockStartPosition: Position;
    blockEndPosition?: Position;
}
export interface LiquidTagBaseCase extends LiquidTagNode<string, string> {
}
export interface LiquidTagEcho extends LiquidTagNode<NamedTags.echo, LiquidVariable> {
}
export interface LiquidTagAssign extends LiquidTagNode<NamedTags.assign, AssignMarkup> {
}
export interface AssignMarkup extends ASTNode<NodeTypes.AssignMarkup> {
    name: string;
    value: LiquidVariable;
}
export interface LiquidTagIncrement extends LiquidTagNode<NamedTags.increment, LiquidVariableLookup> {
}
export interface LiquidTagDecrement extends LiquidTagNode<NamedTags.decrement, LiquidVariableLookup> {
}
export interface LiquidTagCapture extends LiquidTagNode<NamedTags.capture, LiquidVariableLookup> {
}
export interface LiquidTagCycle extends LiquidTagNode<NamedTags.cycle, CycleMarkup> {
}
export interface CycleMarkup extends ASTNode<NodeTypes.CycleMarkup> {
    groupName: LiquidExpression | null;
    args: LiquidExpression[];
}
export interface LiquidTagCase extends LiquidTagNode<NamedTags.case, LiquidExpression> {
}
export interface LiquidBranchWhen extends LiquidBranchNode<NamedTags.when, LiquidExpression[]> {
}
export interface LiquidTagForm extends LiquidTagNode<NamedTags.form, LiquidArgument[]> {
}
export interface LiquidTagFor extends LiquidTagNode<NamedTags.for, ForMarkup> {
}
export interface ForMarkup extends ASTNode<NodeTypes.ForMarkup> {
    variableName: string;
    collection: LiquidExpression;
    reversed: boolean;
    args: LiquidNamedArgument[];
}
export interface LiquidTagTablerow extends LiquidTagNode<NamedTags.tablerow, ForMarkup> {
}
export interface LiquidTagIf extends LiquidTagConditional<NamedTags.if> {
}
export interface LiquidTagUnless extends LiquidTagConditional<NamedTags.unless> {
}
export interface LiquidBranchElsif extends LiquidBranchNode<NamedTags.elsif, LiquidConditionalExpression> {
}
export interface LiquidTagConditional<Name> extends LiquidTagNode<Name, LiquidConditionalExpression> {
}
export declare type LiquidConditionalExpression = LiquidLogicalExpression | LiquidComparison | LiquidExpression;
export interface LiquidLogicalExpression extends ASTNode<NodeTypes.LogicalExpression> {
    relation: 'and' | 'or';
    left: LiquidConditionalExpression;
    right: LiquidConditionalExpression;
}
export interface LiquidComparison extends ASTNode<NodeTypes.Comparison> {
    comparator: Comparators;
    left: LiquidConditionalExpression;
    right: LiquidConditionalExpression;
}
export interface LiquidTagPaginate extends LiquidTagNode<NamedTags.paginate, PaginateMarkup> {
}
export interface PaginateMarkup extends ASTNode<NodeTypes.PaginateMarkup> {
    collection: LiquidExpression;
    pageSize: LiquidExpression;
    args: LiquidNamedArgument[];
}
export interface LiquidTagRender extends LiquidTagNode<NamedTags.render, RenderMarkup> {
}
export interface LiquidTagInclude extends LiquidTagNode<NamedTags.include, RenderMarkup> {
}
export interface LiquidTagSection extends LiquidTagNode<NamedTags.section, LiquidString> {
}
export interface LiquidTagSections extends LiquidTagNode<NamedTags.sections, LiquidString> {
}
export interface LiquidTagLayout extends LiquidTagNode<NamedTags.layout, LiquidExpression> {
}
export interface LiquidTagLiquid extends LiquidTagNode<NamedTags.liquid, LiquidStatement[]> {
}
export interface RenderMarkup extends ASTNode<NodeTypes.RenderMarkup> {
    snippet: LiquidString | LiquidVariableLookup;
    alias: string | null;
    variable: RenderVariableExpression | null;
    args: LiquidNamedArgument[];
}
export interface RenderVariableExpression extends ASTNode<NodeTypes.RenderVariableExpression> {
    kind: 'for' | 'with';
    name: LiquidExpression;
}
export declare type LiquidBranch = LiquidBranchUnnamed | LiquidBranchBaseCase | LiquidBranchNamed;
export declare type LiquidBranchNamed = LiquidBranchElsif | LiquidBranchWhen;
interface LiquidBranchNode<Name, Markup> extends ASTNode<NodeTypes.LiquidBranch> {
    name: Name;
    markup: Markup;
    children: LiquidHtmlNode[];
    whitespaceStart: '-' | '';
    whitespaceEnd: '-' | '';
    blockStartPosition: Position;
}
export interface LiquidBranchUnnamed extends LiquidBranchNode<null, string> {
}
export interface LiquidBranchBaseCase extends LiquidBranchNode<string, string> {
}
export interface LiquidDrop extends ASTNode<NodeTypes.LiquidDrop> {
    markup: string | LiquidVariable;
    whitespaceStart: '-' | '';
    whitespaceEnd: '-' | '';
}
interface LiquidVariable extends ASTNode<NodeTypes.LiquidVariable> {
    expression: LiquidExpression;
    filters: LiquidFilter[];
    rawSource: string;
}
export declare type LiquidExpression = LiquidString | LiquidNumber | LiquidLiteral | LiquidRange | LiquidVariableLookup;
interface LiquidFilter extends ASTNode<NodeTypes.LiquidFilter> {
    name: string;
    args: LiquidArgument[];
}
declare type LiquidArgument = LiquidExpression | LiquidNamedArgument;
interface LiquidNamedArgument extends ASTNode<NodeTypes.NamedArgument> {
    name: string;
    value: LiquidExpression;
}
interface LiquidString extends ASTNode<NodeTypes.String> {
    single: boolean;
    value: string;
}
interface LiquidNumber extends ASTNode<NodeTypes.Number> {
    value: string;
}
interface LiquidRange extends ASTNode<NodeTypes.Range> {
    start: LiquidExpression;
    end: LiquidExpression;
}
interface LiquidLiteral extends ASTNode<NodeTypes.LiquidLiteral> {
    keyword: ConcreteLiquidLiteral['keyword'];
    value: ConcreteLiquidLiteral['value'];
}
interface LiquidVariableLookup extends ASTNode<NodeTypes.VariableLookup> {
    name: string | null;
    lookups: LiquidExpression[];
}
export declare type HtmlNode = HtmlComment | HtmlElement | HtmlVoidElement | HtmlSelfClosingElement | HtmlRawNode;
export interface HtmlElement extends HtmlNodeBase<NodeTypes.HtmlElement> {
    name: (TextNode | LiquidDrop)[];
    children: LiquidHtmlNode[];
    blockEndPosition: Position;
}
export interface HtmlSelfClosingElement extends HtmlNodeBase<NodeTypes.HtmlSelfClosingElement> {
    name: (TextNode | LiquidDrop)[];
}
export interface HtmlVoidElement extends HtmlNodeBase<NodeTypes.HtmlVoidElement> {
    name: string;
}
export interface HtmlRawNode extends HtmlNodeBase<NodeTypes.HtmlRawNode> {
    body: RawMarkup;
    name: string;
    blockEndPosition: Position;
}
export declare enum RawMarkupKinds {
    css = "css",
    html = "html",
    javascript = "javascript",
    json = "json",
    markdown = "markdown",
    typescript = "typescript",
    text = "text"
}
export interface RawMarkup extends ASTNode<NodeTypes.RawMarkup> {
    kind: RawMarkupKinds;
    value: string;
}
export interface HtmlDoctype extends ASTNode<NodeTypes.HtmlDoctype> {
    legacyDoctypeString: string | null;
}
export interface HtmlComment extends ASTNode<NodeTypes.HtmlComment> {
    body: string;
}
export interface HtmlNodeBase<T> extends ASTNode<T> {
    attributes: AttributeNode[];
    blockStartPosition: Position;
}
export declare type AttributeNode = LiquidNode | AttrSingleQuoted | AttrDoubleQuoted | AttrUnquoted | AttrEmpty;
export interface AttrSingleQuoted extends AttributeNodeBase<NodeTypes.AttrSingleQuoted> {
}
export interface AttrDoubleQuoted extends AttributeNodeBase<NodeTypes.AttrDoubleQuoted> {
}
export interface AttrUnquoted extends AttributeNodeBase<NodeTypes.AttrUnquoted> {
}
export interface AttrEmpty extends ASTNode<NodeTypes.AttrEmpty> {
    name: (TextNode | LiquidDrop)[];
}
export declare type ValueNode = TextNode | LiquidNode;
export interface AttributeNodeBase<T> extends ASTNode<T> {
    name: (TextNode | LiquidDrop)[];
    value: ValueNode[];
    attributePosition: Position;
}
export interface TextNode extends ASTNode<NodeTypes.TextNode> {
    value: string;
}
export interface ASTNode<T> {
    type: T;
    position: Position;
    source: string;
}
export declare function isBranchedTag(node: LiquidHtmlNode): boolean;
export declare function toLiquidHtmlAST(source: string): DocumentNode;
export declare function cstToAst(cst: LiquidHtmlCST | ConcreteAttributeNode[]): LiquidHtmlNode[];
export declare function walk(ast: LiquidHtmlNode, fn: (ast: LiquidHtmlNode, parentNode: LiquidHtmlNode | undefined) => void, parentNode?: LiquidHtmlNode): void;
export {};
