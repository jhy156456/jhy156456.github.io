import { Parser } from 'prettier';
import { Comparators, NamedTags } from '../types';
export declare enum ConcreteNodeTypes {
    HtmlDoctype = "HtmlDoctype",
    HtmlComment = "HtmlComment",
    HtmlRawTag = "HtmlRawTag",
    HtmlVoidElement = "HtmlVoidElement",
    HtmlSelfClosingElement = "HtmlSelfClosingElement",
    HtmlTagOpen = "HtmlTagOpen",
    HtmlTagClose = "HtmlTagClose",
    AttrSingleQuoted = "AttrSingleQuoted",
    AttrDoubleQuoted = "AttrDoubleQuoted",
    AttrUnquoted = "AttrUnquoted",
    AttrEmpty = "AttrEmpty",
    LiquidDrop = "LiquidDrop",
    LiquidRawTag = "LiquidRawTag",
    LiquidTag = "LiquidTag",
    LiquidTagOpen = "LiquidTagOpen",
    LiquidTagClose = "LiquidTagClose",
    TextNode = "TextNode",
    YAMLFrontmatter = "YAMLFrontmatter",
    LiquidVariable = "LiquidVariable",
    LiquidFilter = "LiquidFilter",
    NamedArgument = "NamedArgument",
    LiquidLiteral = "LiquidLiteral",
    VariableLookup = "VariableLookup",
    String = "String",
    Number = "Number",
    Range = "Range",
    Comparison = "Comparison",
    Condition = "Condition",
    AssignMarkup = "AssignMarkup",
    CycleMarkup = "CycleMarkup",
    ForMarkup = "ForMarkup",
    RenderMarkup = "RenderMarkup",
    PaginateMarkup = "PaginateMarkup",
    RenderVariableExpression = "RenderVariableExpression"
}
export declare const LiquidLiteralValues: {
    nil: null;
    null: null;
    true: true;
    false: false;
    blank: "";
    empty: "";
};
export interface Parsers {
    [astFormat: string]: Parser;
}
export interface ConcreteBasicNode<T> {
    type: T;
    source: string;
    locStart: number;
    locEnd: number;
}
export interface ConcreteHtmlNodeBase<T> extends ConcreteBasicNode<T> {
    attrList?: ConcreteAttributeNode[];
}
export interface ConcreteHtmlDoctype extends ConcreteBasicNode<ConcreteNodeTypes.HtmlDoctype> {
    legacyDoctypeString: string | null;
}
export interface ConcreteHtmlComment extends ConcreteBasicNode<ConcreteNodeTypes.HtmlComment> {
    body: string;
}
export interface ConcreteHtmlRawTag extends ConcreteHtmlNodeBase<ConcreteNodeTypes.HtmlRawTag> {
    name: string;
    body: string;
    blockStartLocStart: number;
    blockStartLocEnd: number;
    blockEndLocStart: number;
    blockEndLocEnd: number;
}
export interface ConcreteHtmlVoidElement extends ConcreteHtmlNodeBase<ConcreteNodeTypes.HtmlVoidElement> {
    name: string;
}
export interface ConcreteHtmlSelfClosingElement extends ConcreteHtmlNodeBase<ConcreteNodeTypes.HtmlSelfClosingElement> {
    name: (ConcreteTextNode | ConcreteLiquidDrop)[];
}
export interface ConcreteHtmlTagOpen extends ConcreteHtmlNodeBase<ConcreteNodeTypes.HtmlTagOpen> {
    name: (ConcreteTextNode | ConcreteLiquidDrop)[];
}
export interface ConcreteHtmlTagClose extends ConcreteHtmlNodeBase<ConcreteNodeTypes.HtmlTagClose> {
    name: (ConcreteTextNode | ConcreteLiquidDrop)[];
}
export interface ConcreteAttributeNodeBase<T> extends ConcreteBasicNode<T> {
    name: (ConcreteLiquidDrop | ConcreteTextNode)[];
    value: (ConcreteLiquidNode | ConcreteTextNode)[];
}
export declare type ConcreteAttributeNode = ConcreteLiquidNode | ConcreteAttrSingleQuoted | ConcreteAttrDoubleQuoted | ConcreteAttrUnquoted | ConcreteAttrEmpty;
export interface ConcreteAttrSingleQuoted extends ConcreteAttributeNodeBase<ConcreteNodeTypes.AttrSingleQuoted> {
}
export interface ConcreteAttrDoubleQuoted extends ConcreteAttributeNodeBase<ConcreteNodeTypes.AttrDoubleQuoted> {
}
export interface ConcreteAttrUnquoted extends ConcreteAttributeNodeBase<ConcreteNodeTypes.AttrUnquoted> {
}
export interface ConcreteAttrEmpty extends ConcreteBasicNode<ConcreteNodeTypes.AttrEmpty> {
    name: (ConcreteLiquidDrop | ConcreteTextNode)[];
}
export declare type ConcreteLiquidNode = ConcreteLiquidRawTag | ConcreteLiquidTagOpen | ConcreteLiquidTagClose | ConcreteLiquidTag | ConcreteLiquidDrop;
interface ConcreteBasicLiquidNode<T> extends ConcreteBasicNode<T> {
    whitespaceStart: null | '-';
    whitespaceEnd: null | '-';
}
export interface ConcreteLiquidRawTag extends ConcreteBasicLiquidNode<ConcreteNodeTypes.LiquidRawTag> {
    name: string;
    body: string;
    markup: string;
    delimiterWhitespaceStart: null | '-';
    delimiterWhitespaceEnd: null | '-';
    blockStartLocStart: number;
    blockStartLocEnd: number;
    blockEndLocStart: number;
    blockEndLocEnd: number;
}
export declare type ConcreteLiquidTagOpen = ConcreteLiquidTagOpenBaseCase | ConcreteLiquidTagOpenNamed;
export declare type ConcreteLiquidTagOpenNamed = ConcreteLiquidTagOpenCase | ConcreteLiquidTagOpenCapture | ConcreteLiquidTagOpenIf | ConcreteLiquidTagOpenUnless | ConcreteLiquidTagOpenForm | ConcreteLiquidTagOpenFor | ConcreteLiquidTagOpenPaginate | ConcreteLiquidTagOpenTablerow;
export interface ConcreteLiquidTagOpenNode<Name, Markup> extends ConcreteBasicLiquidNode<ConcreteNodeTypes.LiquidTagOpen> {
    name: Name;
    markup: Markup;
}
export interface ConcreteLiquidTagOpenBaseCase extends ConcreteLiquidTagOpenNode<string, string> {
}
export interface ConcreteLiquidTagOpenCapture extends ConcreteLiquidTagOpenNode<NamedTags.capture, ConcreteLiquidVariableLookup> {
}
export interface ConcreteLiquidTagOpenCase extends ConcreteLiquidTagOpenNode<NamedTags.case, ConcreteLiquidExpression> {
}
export interface ConcreteLiquidTagWhen extends ConcreteLiquidTagNode<NamedTags.when, ConcreteLiquidExpression[]> {
}
export interface ConcreteLiquidTagOpenIf extends ConcreteLiquidTagOpenNode<NamedTags.if, ConcreteLiquidCondition[]> {
}
export interface ConcreteLiquidTagOpenUnless extends ConcreteLiquidTagOpenNode<NamedTags.unless, ConcreteLiquidCondition[]> {
}
export interface ConcreteLiquidTagElsif extends ConcreteLiquidTagNode<NamedTags.elsif, ConcreteLiquidCondition[]> {
}
export interface ConcreteLiquidCondition extends ConcreteBasicNode<ConcreteNodeTypes.Condition> {
    relation: 'and' | 'or' | null;
    expression: ConcreteLiquidComparison | ConcreteLiquidExpression;
}
export interface ConcreteLiquidComparison extends ConcreteBasicNode<ConcreteNodeTypes.Comparison> {
    comparator: Comparators;
    left: ConcreteLiquidExpression;
    right: ConcreteLiquidExpression;
}
export interface ConcreteLiquidTagOpenForm extends ConcreteLiquidTagOpenNode<NamedTags.form, ConcreteLiquidArgument[]> {
}
export interface ConcreteLiquidTagOpenFor extends ConcreteLiquidTagOpenNode<NamedTags.for, ConcreteLiquidTagForMarkup> {
}
export interface ConcreteLiquidTagForMarkup extends ConcreteBasicNode<ConcreteNodeTypes.ForMarkup> {
    variableName: string;
    collection: ConcreteLiquidExpression;
    reversed: 'reversed' | null;
    args: ConcreteLiquidNamedArgument[];
}
export interface ConcreteLiquidTagOpenTablerow extends ConcreteLiquidTagOpenNode<NamedTags.tablerow, ConcreteLiquidTagForMarkup> {
}
export interface ConcreteLiquidTagOpenPaginate extends ConcreteLiquidTagOpenNode<NamedTags.paginate, ConcretePaginateMarkup> {
}
export interface ConcretePaginateMarkup extends ConcreteBasicNode<ConcreteNodeTypes.PaginateMarkup> {
    collection: ConcreteLiquidExpression;
    pageSize: ConcreteLiquidExpression;
    args: ConcreteLiquidNamedArgument[] | null;
}
export interface ConcreteLiquidTagClose extends ConcreteBasicLiquidNode<ConcreteNodeTypes.LiquidTagClose> {
    name: string;
}
export declare type ConcreteLiquidTag = ConcreteLiquidTagNamed | ConcreteLiquidTagBaseCase;
export declare type ConcreteLiquidTagNamed = ConcreteLiquidTagAssign | ConcreteLiquidTagCycle | ConcreteLiquidTagEcho | ConcreteLiquidTagIncrement | ConcreteLiquidTagDecrement | ConcreteLiquidTagElsif | ConcreteLiquidTagInclude | ConcreteLiquidTagLayout | ConcreteLiquidTagLiquid | ConcreteLiquidTagRender | ConcreteLiquidTagSection | ConcreteLiquidTagSections | ConcreteLiquidTagWhen;
export interface ConcreteLiquidTagNode<Name, Markup> extends ConcreteBasicLiquidNode<ConcreteNodeTypes.LiquidTag> {
    markup: Markup;
    name: Name;
}
export interface ConcreteLiquidTagBaseCase extends ConcreteLiquidTagNode<string, string> {
}
export interface ConcreteLiquidTagEcho extends ConcreteLiquidTagNode<NamedTags.echo, ConcreteLiquidVariable> {
}
export interface ConcreteLiquidTagIncrement extends ConcreteLiquidTagNode<NamedTags.increment, ConcreteLiquidVariableLookup> {
}
export interface ConcreteLiquidTagDecrement extends ConcreteLiquidTagNode<NamedTags.decrement, ConcreteLiquidVariableLookup> {
}
export interface ConcreteLiquidTagSection extends ConcreteLiquidTagNode<NamedTags.section, ConcreteStringLiteral> {
}
export interface ConcreteLiquidTagSections extends ConcreteLiquidTagNode<NamedTags.sections, ConcreteStringLiteral> {
}
export interface ConcreteLiquidTagLayout extends ConcreteLiquidTagNode<NamedTags.layout, ConcreteLiquidExpression> {
}
export interface ConcreteLiquidTagLiquid extends ConcreteLiquidTagNode<NamedTags.liquid, ConcreteLiquidLiquidTagNode[]> {
}
export declare type ConcreteLiquidLiquidTagNode = ConcreteLiquidTagOpen | ConcreteLiquidTagClose | ConcreteLiquidTag | ConcreteLiquidRawTag;
export interface ConcreteLiquidTagAssign extends ConcreteLiquidTagNode<NamedTags.assign, ConcreteLiquidTagAssignMarkup> {
}
export interface ConcreteLiquidTagAssignMarkup extends ConcreteBasicNode<ConcreteNodeTypes.AssignMarkup> {
    name: string;
    value: ConcreteLiquidVariable;
}
export interface ConcreteLiquidTagCycle extends ConcreteLiquidTagNode<NamedTags.cycle, ConcreteLiquidTagCycleMarkup> {
}
export interface ConcreteLiquidTagCycleMarkup extends ConcreteBasicNode<ConcreteNodeTypes.CycleMarkup> {
    groupName: ConcreteLiquidExpression | null;
    args: ConcreteLiquidExpression[];
}
export interface ConcreteLiquidTagRender extends ConcreteLiquidTagNode<NamedTags.render, ConcreteLiquidTagRenderMarkup> {
}
export interface ConcreteLiquidTagInclude extends ConcreteLiquidTagNode<NamedTags.include, ConcreteLiquidTagRenderMarkup> {
}
export interface ConcreteLiquidTagRenderMarkup extends ConcreteBasicNode<ConcreteNodeTypes.RenderMarkup> {
    snippet: ConcreteStringLiteral | ConcreteLiquidVariableLookup;
    alias: string | null;
    variable: ConcreteRenderVariableExpression | null;
    args: ConcreteLiquidNamedArgument[];
}
export interface ConcreteRenderVariableExpression extends ConcreteBasicNode<ConcreteNodeTypes.RenderVariableExpression> {
    kind: 'for' | 'with';
    name: ConcreteLiquidExpression;
}
export interface ConcreteLiquidDrop extends ConcreteBasicLiquidNode<ConcreteNodeTypes.LiquidDrop> {
    markup: ConcreteLiquidVariable | string;
}
export interface ConcreteLiquidVariable extends ConcreteBasicNode<ConcreteNodeTypes.LiquidVariable> {
    expression: ConcreteLiquidExpression;
    filters: ConcreteLiquidFilter[];
    rawSource: string;
}
export interface ConcreteLiquidFilter extends ConcreteBasicNode<ConcreteNodeTypes.LiquidFilter> {
    name: string;
    args: ConcreteLiquidArgument[];
}
export declare type ConcreteLiquidArgument = ConcreteLiquidExpression | ConcreteLiquidNamedArgument;
export interface ConcreteLiquidNamedArgument extends ConcreteBasicNode<ConcreteNodeTypes.NamedArgument> {
    name: string;
    value: ConcreteLiquidExpression;
}
export declare type ConcreteLiquidExpression = ConcreteStringLiteral | ConcreteNumberLiteral | ConcreteLiquidLiteral | ConcreteLiquidRange | ConcreteLiquidVariableLookup;
export interface ConcreteStringLiteral extends ConcreteBasicNode<ConcreteNodeTypes.String> {
    value: string;
    single: boolean;
}
export interface ConcreteNumberLiteral extends ConcreteBasicNode<ConcreteNodeTypes.Number> {
    value: string;
}
export interface ConcreteLiquidLiteral extends ConcreteBasicNode<ConcreteNodeTypes.LiquidLiteral> {
    keyword: keyof typeof LiquidLiteralValues;
    value: typeof LiquidLiteralValues[keyof typeof LiquidLiteralValues];
}
export interface ConcreteLiquidRange extends ConcreteBasicNode<ConcreteNodeTypes.Range> {
    start: ConcreteLiquidExpression;
    end: ConcreteLiquidExpression;
}
export interface ConcreteLiquidVariableLookup extends ConcreteBasicNode<ConcreteNodeTypes.VariableLookup> {
    name: string | null;
    lookups: ConcreteLiquidExpression[];
}
export declare type ConcreteHtmlNode = ConcreteHtmlDoctype | ConcreteHtmlComment | ConcreteHtmlRawTag | ConcreteHtmlVoidElement | ConcreteHtmlSelfClosingElement | ConcreteHtmlTagOpen | ConcreteHtmlTagClose;
export interface ConcreteTextNode extends ConcreteBasicNode<ConcreteNodeTypes.TextNode> {
    value: string;
}
export interface ConcreteYamlFrontmatterNode extends ConcreteBasicNode<ConcreteNodeTypes.YAMLFrontmatter> {
    body: string;
}
export declare type LiquidHtmlConcreteNode = ConcreteHtmlNode | ConcreteLiquidNode | ConcreteTextNode | ConcreteYamlFrontmatterNode;
export declare type LiquidHtmlCST = LiquidHtmlConcreteNode[];
export declare function toLiquidHtmlCST(source: string): LiquidHtmlCST;
export {};
